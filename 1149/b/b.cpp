/* Generated by powerful Codeforces Tool
 * Author: calabash_boy_love_15 
 * Time: 2019-04-29 23:31:51
 * Personal Code Template: https://github.com/4thcalabash/ACM-Code-Library
**/
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;
#ifdef __LOCAL_DEBUG__
# define _debug(fmt, ...) fprintf(stderr, "\033[91m[%s %3d]: " fmt "\n\033[0m", \
  __func__,__LINE__, ##__VA_ARGS__)
#else
# define _debug(...) (void(0))
#endif
#define PB(x) push_back(x)
#define rep(i,l,r) for (int i = l,_ = r;i< _;i++)
#define REP(i,l,r) for (int i=l,_=r;i<=_;i++)
#define leave(x) do {cout<<#x<<endl;fflush(stdout);return 0;}while (0);
#define untie do{ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);}while (0)
#define range(x) x.begin(),x.end()
typedef long long LL;
typedef long long ll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef long double db;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
const int inf = 0x3f3f3f3f;
const ll inf_ll = 0x3f3f3f3f3f3f3f3fLL;
/************* header ******************/
const int maxn = 1e5+100;
const int maxtrie = 3000;
int n,q;
struct Trie{
    int root = 1;
    int cnt = 1;
    int fa[maxtrie];
    int len[maxtrie];
    int nxt[maxtrie][26];
    int add(int ch){
        if (!nxt[now][ch]){
        
            nxt[now][ch] = ++cnt;
            fa[cnt] = now;
            len[cnt] = len[now] + 1;
        }
        return now = nxt[now][ch];
    }
    void back(){
        now = fa[now];
    }
    int now = 1;
}trie[3];
char s[maxn];
int pos[maxtrie][3];
int nxt[maxn][26];
map<tuple<int,int,int>,int> ID;
int ans[maxtrie];
vector<tuple<int,int,int> > ops[3];
bool ans_of_trie[200000000];
queue<tuple<int,int,int> > Q[maxtrie];
int CNT0,CNT1,CNT2;
inline int get_id(int a,int b,int c){
    return a + b * CNT0 + c * CNT0 * CNT1;
}
void bfs(){
    int cnt0 = trie[0].cnt;
    int cnt1 = trie[1].cnt;
    int cnt2 = trie[2].cnt;
    tie(CNT0,CNT1,CNT2) = make_tuple(cnt0,cnt1,cnt2);
    for (int i=1;i<=cnt0;i++){
        for (int j=1;j<=cnt1;j++){
            for (int k=1;k<=cnt2;k++){
                int sum = i + j + k;
                Q[sum].push(make_tuple(i,j,k));
            }
        }
    }
    for (int i=0;i<maxtrie;i++){
        for (auto tp : Q[i]){
            int a,b,c;
            tie(a,b,c) = tp;
            int id = get_id(a,b,c);
            if (ID.find(tp) != ID.end){
                int idd = ID[tp];
                ans[idd] = ans_of_trie[id];
            }
            if(!ans[id])continue;

}
int main(){
    scanf("%d%d",&n,&q);
    scanf("%s",s+1);
    for (int i=0;i<q;i++){
        static char op[4];
        int idx;
        static char chs[4];
        scanf("%s%d",op,&idx);
        idx --;
        if (op[0] == '+'){
            scanf("%s",chs);
            int ch = chs[0];
            trie[idx].add(ch);
        }else{
            trie[idx].back();
        }
        ID[make_tuple(trie[0].now,trie[1].now,trie[2].now)] = i;
    }
    memset(nxt,-1,sizeof nxt);
    for (int i=n;i>=0;i--){
        for (int ch=0;ch<26;ch++){
            nxt[i][ch] = nxt[i+1][ch];
        }
        if (i)
        nxt[i][s[i] - 'a'] = i;
    }
    int cnt0 = trie[0].cnt;
    int cnt1 = trie[1].cnt;
    int cnt2 = trie[2].cnt;
    bfs();
    for (int i=0;i<q;i++){
        printf("%d\n",ans[i]);
    }
    return 0;
}
